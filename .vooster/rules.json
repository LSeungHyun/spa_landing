{
  "rules": [
    {
      "type": "prd",
      "content": "# 제품 요구 사항 문서 (PRD)\n\n## 1. 개요\nSmart Prompt Assistant는 AI 도움으로 프롬프트 품질을 즉시 향상시키는 크롬 확장 및 웹 데모 서비스이다. 비전문가도 클릭 한 번으로 전문가급 프롬프트를 얻어 업무 효율을 극대화할 수 있다.\n\n## 2. 문제 정의\n- 많은 사용자가 막연한 아이디어를 구체적 프롬프트로 변환하지 못해 AI 도구 활용 효과가 낮다.  \n- 기존 서비스는 복잡한 설정, 높은 비용, 제한적 맞춤화로 사용자 진입 장벽이 높다.\n\n## 3. 목표 및 목적\n- 1차 목표: 자연어 입력을 고품질 프롬프트로 자동 변환하여 작업 시간을 50% 단축.\n- 2차 목표: 페르소나별 템플릿 제공으로 사용자 만족도 80% 이상 달성.\n- 성공 지표  \n  • 주간 활성 사용자(WAU) 5,000명 달성  \n  • 프롬프트 개선 클릭당 NPS 50 이상  \n  • 크롬 익스텐션 설치→사용 전환율 60% 달성  \n\n## 4. 대상 사용자\n### 주요 사용자\n- AI 도움을 받고 싶은 지식 근로자(25~45세), 비전문가, 비기술 배경.\n### 부차 사용자\n- 스타트업, 에이전시, 교육 기관.\n\n## 5. 사용자 스토리\n- PM/개발자로서, 난해한 기능 설명을 넣으면 명확한 기획서용 프롬프트를 받고 싶다.  \n- 콘텐츠 크리에이터로서, 아이디어 키워드만 입력해 완성형 콘텐츠 프롬프트를 얻고 싶다.  \n- 마케터로서, 캠페인 목표를 입력해 데이터 기반 광고 프롬프트를 받고 싶다.\n\n## 6. 기능 요구 사항\n### 핵심 기능\n1. AI 프롬프트 개선  \n   - 입력창에 자연어 입력 → Gemini 2.5 Flash로 개선 → Before/After 비교 표시  \n   - 수락/재생성 버튼 제공  \n   - 수락 시 클립보드 복사 및 저장  \n   - 성능 기준: 3초 내 결과 반환  \n2. 페르소나 템플릿  \n   - 6개 페르소나 버튼(개발자, 크리에이터 등)  \n   - 버튼 클릭 시 샘플 프롬프트 자동 삽입  \n3. 사용량 제한  \n   - IP 기준 일 3회 무료 사용  \n   - Redis로 카운트, 24시간 후 자동 초기화  \n   - 초과 시 사전 등록 페이지로 리다이렉트  \n4. 크롬 확장  \n   - ChatGPT 사이드패널에 버튼 삽입  \n   - 원클릭으로 현재 프롬프트 개선  \n5. 웹 데모  \n   - 4개 샘플 프롬프트 카드  \n   - 실시간 타이핑 애니메이션  \n   - 키보드 단축키(⌘/Ctrl+↵) 지원  \n\n### 부가 기능\n- 다국어 번역 모드  \n- 히스토리 보관함(30일)  \n- 공유 링크 생성  \n- 팀 요금제(추후)  \n\n## 7. 비기능 요구 사항\n- 성능: 95퍼센타일 응답 3초 이하  \n- 보안: OAuth2, HTTPS, 데이터 암호화 at rest  \n- 사용성: WCAG 2.1 AA 준수, 다크모드  \n- 확장성: 동시 10k 요청 처리  \n- 호환성: Chrome 114+, Edge 114+, 모바일 웹 Safari/Chrome  \n\n## 8. 기술 고려 사항\n- 아키텍처: Next.js 14 App Router + Server Actions  \n- AI 연동: Google Gemini Flash API  \n- 데이터: Supabase Postgres, Redis 캐싱  \n- 인증: Supabase Auth, OAuth Google  \n- 배포: Vercel + Cloudflare CDN  \n- 확장: Manifest V3 기반 크롬 익스텐션  \n```typescript\nexport const MODELS = {\n  CHAT: 'gemini-2.0-flash',\n  IMPROVE: 'gemini-2.5-flash',\n  IMPROVE_TEST: 'gemini-2.0-flash',\n  GENERATE: 'gemini-2.0-flash',\n};\n```\n\n## 9. 성공 지표 및 KPI\n- WAU, MAU, 설치 전환율  \n- 1인당 일평균 개선 클릭수  \n- 응답 지연 평균  \n- 유료 전환율(베타 종료 후)  \n\n## 10. 일정 및 마일스톤\n| 단계 | 기간 | 주요 산출물 |\n|------|------|-------------|\n| Phase 1 MVP | M0~M1 | 웹 데모, 프롬프트 개선, 사용량 제한 |\n| Phase 2 | M2 | 크롬 확장, 페르소나 템플릿, 분석 대시보드 |\n| Phase 3 | M3~M4 | 히스토리, 다국어, 팀 요금제, 공식 런치 |\n\n## 11. 위험 및 완화 전략\n- API 비용 증가 → 무료 모델 우선, 캐싱 강화  \n- Google 정책 변경 → 대체 모델 조사(Claude, Llama)  \n- 남용 및 DoS → Redis Rate Limit, CAPTCHA  \n- 사용자 저조 → First Mover Club 리워드, 콘텐츠 마케팅  \n\n## 12. 향후 고려 사항\n- GPT-4o 등 유료 모델 옵션  \n- 파이어폭스·사파리 확장 포팅  \n- 오프라인 모드(로컬 LLM 연동)  \n- 커뮤니티 마켓플레이스(사용자 템플릿 거래)",
      "writedAt": "2025-07-12T16:58:47.054Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **프로젝트 개요**  \n  Smart Prompt Assistant는 크롬 확장 및 웹 데모 형태로 제공되며, 사용자의 자연어 입력을 Google Gemini Flash API를 통해 전문가급 프롬프트로 즉시 변환합니다. Next.js 14 App Router와 Server Actions 기반 서버 렌더링+API 핸들러를 활용하여 빠른 응답성과 SEO 친화성을 확보합니다.\n- **핵심 기술 스택**  \n  Next.js 14, React, TypeScript, Supabase(Postgres/Auth), Redis, Google Gemini Flash, Vercel, Cloudflare CDN, Chrome Extension Manifest V3\n- **주요 기술 목표**  \n  • 95퍼센타일 응답 3초 이하 유지  \n  • 일일 10k 동시 요청 처리 가능  \n  • 크롬 익스텐션 설치→사용 전환율 60% 이상  \n- **핵심 가정사항**  \n  • Google Gemini Flash API 안정성 보장  \n  • Supabase 및 Redis로 확장성 있는 세션·캐시 관리 가능  \n  • Vercel/Cloudflare를 통한 글로벌 CDN 배포 성능 충족  \n\n## 2. Tech Stack\n\n| Category        | Technology / Library        | Reasoning (선택 이유)                                                |\n| --------------- | --------------------------- | -------------------------------------------------------------------- |\n| Frontend        | Next.js 14 (App Router)     | SSR/SSG 지원, Server Actions로 API 통합, SEO·퍼포먼스 우수           |\n| 언어·타입       | TypeScript                  | 정적 타입 검사, 유지보수성·안정성 향상                              |\n| 스타일링        | Tailwind CSS                | 유틸리티 퍼스트, 빠른 UI 개발, 커스텀 좌우 유연성                   |\n| 백엔드 (API)    | Next.js Server Actions      | 프론트엔드와 동일 코드베이스, 별도 서버 불필요                        |\n| 데이터베이스    | Supabase Postgres           | 완전 관리형 Postgres, 실시간 기능 및 Auth 통합 용이                |\n| 캐싱·RateLimit  | Redis                       | 고속 인메모리 캐시·레이트 리미트 집계, 사용량 제한 구현             |\n| 인증·인가       | Supabase Auth + OAuth2      | 내장 소셜 로그인(OAuth), JWT 기반 인증 관리 간편                    |\n| AI 연동         | Google Gemini Flash API     | 프롬프트 개선 전문화 모델, 낮은 레이턴시                             |\n| 배포·CDN        | Vercel + Cloudflare CDN     | 자동화 CI/CD, 글로벌 엣지 캐싱                                      |\n| 크롬 확장        | Chrome Extension Manifest V3| 최신 브라우저 호환, 안전한 권한 모델                                 |\n\n## 3. System Architecture Design\n\n### Top-Level Building Blocks\n- **웹 데모 애플리케이션**  \n  - Next.js 14 App Router, Server Actions  \n  - UI 컴포넌트(Tailwind CSS)  \n  - 샘플 프롬프트 카드, 타이핑 애니메이션\n- **크롬 익스텐션**  \n  - Manifest V3 기반 사이드패널 버튼  \n  - 메시지 패싱(Messaging API)으로 백엔드 호출\n- **API 레이어**  \n  - Next.js Server Actions로 프롬프트 개선/생성 API  \n  - OAuth 인증, 요청 제한 로직, Redis 캐싱\n- **데이터 저장소**  \n  - Supabase Postgres: 사용자·히스토리, 사용량 카운트  \n  - Redis: 일일 호출 카운트, 임시 캐시\n- **AI 서비스 통합**  \n  - Google Gemini Flash REST API 호출 및 응답 파싱\n- **인증·보안**  \n  - Supabase Auth(OAuth2), HTTPS, 데이터 암호화 at rest\n\n### Top-Level Component Interaction Diagram\n```mermaid\ngraph TD\n    W[Web Demo] -->|API 호출| B[Next.js Backend]\n    C[Chrome Extension] -->|메시지 패싱| B\n    B -->|SQL/CRUD| DB[Supabase Postgres]\n    B -->|GET/SET| R[Redis Cache]\n    B -->|REST API| A[Google Gemini Flash API]\n    U[Auth Server] -->|JWT| B\n```\n- 웹 데모와 크롬 확장은 공통 Next.js 백엔드 API를 호출  \n- 백엔드는 Redis에 요청 제한 및 캐싱 정보를 저장/조회  \n- Postgres는 사용자 프로필·히스토리·사용량 기록 저장  \n- AI 모델 호출을 통해 프롬프트 개선·생성 결과 반환  \n- Supabase Auth로 OAuth2 로그인 및 JWT 토큰 발급/검증  \n\n### Code Organization & Convention\n**Domain-Driven Organization Strategy**  \n- Domain Separation: user, prompt, usage, auth, extension  \n- Layer-Based Architecture: presentation(UI), business(services), data(access), infra(API 클라이언트)  \n- Feature-Based Modules: src/features/{domain} 구조  \n- Shared Components: src/components/ui, src/lib/utils, src/types\n\n**Universal File & Folder Structure**\n```\n/\n├── apps\n│   ├── web                  # Next.js 웹 데모\n│   │   ├── app              # App Router\n│   │   ├── components       # UI 컴포넌트\n│   │   ├── features         # 도메인별 기능 모듈\n│   │   └── styles\n│   └── extension            # 크롬 익스텐션 소스\n│       ├── src\n│       ├── manifest.json\n│       └── background.js\n├── libs\n│   ├── api                  # Gemini API 클라이언트\n│   ├── auth                 # Supabase Auth 설정\n│   └── db                   # Supabase/Redis 초기화\n├── prisma                   # 스키마 및 마이그레이션\n├── public                   # 정적 자산\n├── scripts                  # 배포/빌드 스크립트\n└── tsconfig.json\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server Communication**: HTTPS REST/Server Actions, JWT Bearer 토큰  \n- **Database Interaction**: Prisma ORM → Supabase Postgres, connection pooling  \n- **External Service Integration**: Google Gemini Flash REST 호출, 재시도 로직  \n- **실시간 통신**: 필요 시 Server-Sent Events(히스토리 피드) 확장 가능  \n- **Data Synchronization**: 캐시 만료 정책(24h) 및 Redis pub/sub 활용\n\n## 4. Performance & Optimization Strategy\n- Next.js ISR/SSR 조합으로 초기 로드 속도 최적화  \n- Redis 캐싱으로 반복 요청·레이트 리미트 처리  \n- 코드 스플리팅 및 이미지 최적화(Tailwind JIT, Vercel Edge)  \n- API 호출 병렬화 및 응답 로깅·모니터링  \n\n## 5. Implementation Roadmap & Milestones\n\n### Phase 1: Foundation (MVP Implementation)\n- **Core Infrastructure**: Next.js 프로젝트 초기화, Supabase/Redis 연결  \n- **Essential Features**: 프롬프트 개선 API, Before/After UI, 일일 사용량 제한  \n- **Basic Security**: OAuth2 로그인, HTTPS 적용  \n- **Development Setup**: Git, Vercel CI/CD 파이프라인  \n- **Timeline**: M0~M1\n\n### Phase 2: Feature Enhancement\n- **Advanced Features**: 페르소나 템플릿, 샘플 카드, 키보드 단축키  \n- **Performance Optimization**: CDN 캐싱 정책, SSR 최적화  \n- **Enhanced Security**: CAPTCHA, CSP 헤더 강화  \n- **Monitoring Implementation**: Sentry, Vercel Analytics  \n- **Timeline**: M2\n\n### Phase 3: Scaling & Optimization\n- **Scalability Implementation**: Auto-scaling Redis 인스턴스, DB Read Replica  \n- **Advanced Integrations**: 다국어 번역 모드, 히스토리 보관함  \n- **Enterprise Features**: 팀 요금제 대시보드  \n- **Compliance & Auditing**: GDPR/ISO 보안 표준 대응  \n- **Timeline**: M3~M4\n\n## 6. Risk Assessment & Mitigation Strategies\n\n### Technical Risk Analysis\n- **Technology Risks**: Gemini API 호출 실패 → 재시도/폴백 모델(Claude) 연동  \n- **Performance Risks**: 동시 10k 요청 과부하 → Redis 캐시·Rate Limit 강화  \n- **Security Risks**: OAuth 토큰 탈취 → HTTPS·JWT 만료 정책 엄격화  \n- **Integration Risks**: Supabase 서비스 장애 → 다중 리전 DB 백업  \n- **Mitigation Strategies**: 장애 대비 이중화, 재시도 로직, SLA 모니터링  \n\n### Project Delivery Risks\n- **Timeline Risks**: 의존성 병목 → 스파이크(개발 예비 시간) 확보  \n- **Resource Risks**: 기술 숙련도 편차 → 초기 온보딩 세션, 코드 리뷰  \n- **Quality Risks**: 테스트 커버리지 부족 → 유닛·통합 테스트 필수화  \n- **Deployment Risks**: 환경별 설정 오류 → IaC 스크립트, 별도 스테이징  \n- **Contingency Plans**: 주요 기능 롤백 전략, 대체 API 플랜 확보  \n\n---",
      "writedAt": "2025-07-12T16:58:47.054Z"
    },
    {
      "type": "guideline",
      "content": "# Code Guidelines for Smart Prompt Assistant\n\n## 1. Project Overview  \nSmart Prompt Assistant combines a Next.js 14 App Router frontend, Next.js Server Actions backend, Google Gemini Flash API, Supabase Postgres/Auth, Redis caching, and a Manifest V3 Chrome Extension. It is deployed on Vercel with Cloudflare CDN.  \nKey architectural decisions:  \n- Use Next.js 14 App Router + Server Actions for unified SSR/SSG and API.  \n- Domain-driven, feature-based modules under `src/features`.  \n- Supabase for persistent storage & auth; Redis for rate‐limiting and caching.  \n- Chrome Extension shares the Next.js backend via Messaging API.  \n\n---\n\n## 2. Core Principles  \n1. **Single Responsibility**: Each module, component, or function MUST do one thing and do it well; max 100 lines.  \n2. **Type Safety**: All functions, components, and API handlers MUST declare explicit TypeScript types or interfaces.  \n3. **Consistent Structure**: File organization MUST follow the `/apps/{web|extension}`, `/libs`, `/prisma`, `/public` hierarchy.  \n4. **Performance-Aware**: Cache repeated API calls in Redis; use Next.js caching options (`fetch(..., { next: { revalidate: 60 } })`).  \n5. **Security-First**: All HTTP endpoints MUST validate JWT from Supabase Auth and sanitize inputs.\n\n---\n\n## 3. Language-Specific Guidelines\n\n### 3.1 TypeScript (Shared)  \n- **File Organization**:  \n  - Use absolute imports with `tsconfig.json` paths (`@/features/prompt`).  \n  - Group by domain: `src/features/{auth,prompt,usage,extension}`.  \n- **Imports**:  \n  - Order: 1) External libs, 2) Aliased internal modules, 3) Relative imports, 4) Styles/assets.  \n  - Use ESLint import/order rule.  \n- **Error Handling**:  \n  - In Server Actions, wrap external calls in `try/catch` and throw custom `ApiError`.  \n  - Expose minimal error messages to frontend; log details server-side.\n\n### 3.2 React / Next.js App Router  \n- **Components**:  \n  - Use functional components with React hooks; no class components.  \n  - Keep `app/` files small: pages call child components in `components/`.  \n- **Server Actions**:  \n  - Annotate with `'use server'` at top of file.  \n  - Validate inputs before calling downstream services.  \n- **Styling**:  \n  - Use Tailwind CSS utility classes; avoid inline styles.  \n  - Extract repeated patterns into `components/ui/` or `styles/`.\n\n### 3.3 Chrome Extension (Manifest V3)  \n- **Structure**:  \n  - `apps/extension/src/` for popup/panel code, `background.ts` for service worker.  \n- **Messaging**:  \n  - Use `chrome.runtime.sendMessage` / `chrome.runtime.onMessage` to call Next.js API.  \n  - Sanitize responses before injecting into the page.\n\n---\n\n## 4. Code Style Rules\n\n### MUST Follow  \n1. **ESLint + Prettier**: Enforce formatting and code quality.  \n   Rationale: Guarantees consistent style and prevents common errors.  \n2. **One Export per File**: Use `export default` or named exports, not both.  \n   Rationale: Simplifies imports and tree‐shaking.  \n3. **Explicit Types**: No implicit `any`; use interfaces/type aliases for props and API responses.  \n   Rationale: Prevents runtime errors, improves developer experience.  \n4. **Descriptive Naming**: Variables, functions, and files must clearly reflect their purpose (`improvePrompt`, not `doIt`).  \n5. **Atomic Tailwind Classes**: Use only utility classes; abstract repeated patterns into `components/ui/Button.tsx`.\n\n### MUST NOT Do  \n1. **No Console Logs in Production**  \n   // MUST NOT:  \n   ```ts\n   console.log('user data', user)  \n   ```  \n   // Logging raw data can leak PII; use structured server‐side logging.  \n2. **No Large Multi-Responsibility Modules**  \n   // MUST NOT:  \n   ```ts\n   // src/features/prompt/PromptService.ts (500 lines)\n   export class PromptService { /* UI, DB, API, cache, auth all in one */ }\n   ```  \n   // Split into `services/`, `db/`, `api/`.  \n3. **No Inline Styles or Hardcoded URLs**  \n4. **No Unsafe Type Assertions (`as any`)**  \n\n---\n\n## 5. Architecture Patterns\n\n### 5.1 Component & Module Structure  \n- **Feature Module**:  \n  ```\n  src/features/prompt/\n    ├── components/     # UI subcomponents\n    ├── services/       # Business logic (API calls, caching)\n    ├── hooks/          # Custom React hooks\n    ├── types.ts        # Domain types/interfaces\n    └── routes.ts       # Server Actions endpoints\n  ```  \n\n- **Shared**:  \n  ```\n  src/components/ui/     # Buttons, Inputs, Cards\n  src/lib/api/           # Gemini API client\n  src/lib/db/            # Supabase & Redis init\n  src/lib/auth/          # Supabase Auth wrapper\n  src/types/             # Global types\n  ```\n\n### 5.2 Data Flow Patterns  \n1. **Client → Server Action**:  \n   - Client calls form `<form action={improvePrompt}>`.  \n2. **Server Action**:  \n   - Validate input → call `libs/api/geminiClient` → cache in Redis → write history to Postgres → return result.  \n3. **Client Rendering**:  \n   - Display before/after, store accepted prompt via another action.\n\n### 5.3 State Management  \n- **Local State**: Page- or component-level via `useState`.  \n- **Server State**: Fetch with Next.js `fetch` and `cache`/`revalidate` options.  \n- **Global Auth State**: Wrap in `AuthContext` using Supabase Auth listener.\n\n### 5.4 API Design Standards  \n- **Naming**: `/api/prompt/improve`, `/api/prompt/generate`.  \n- **HTTP Methods**: POST for create/update, GET for retrieval.  \n- **Response Shape**:  \n  ```ts\n  interface ApiResponse<T> {\n    data: T | null\n    error?: { code: string; message: string }\n  }\n  ```  \n- **Error Codes**: Follow `ApiError` with `code:string`, `status:number`.\n\n---\n\n## 6. Example Code Snippets\n\n```typescript\n// MUST: Server Action with validation, caching, and error handling\n'use server'\nimport { z } from 'zod'\nimport { improvePrompt as geminiImprove } from '@/lib/api/geminiClient'\nimport { redis } from '@/lib/db'\nimport { saveHistory } from '@/features/prompt/services/historyService'\n\nconst ImprovePromptSchema = z.object({ text: z.string().min(1) })\n\nexport async function improvePrompt(data: FormData) {\n  const { text } = ImprovePromptSchema.parse({ text: data.get('prompt') })\n  const cacheKey = `improve:${text}`\n  const cached = await redis.get(cacheKey)\n  if (cached) return JSON.parse(cached) as string\n\n  try {\n    const improved = await geminiImprove(text)\n    await redis.set(cacheKey, JSON.stringify(improved), { EX: 3600 })\n    await saveHistory({ original: text, improved })\n    return improved\n  } catch (e) {\n    console.error(e)\n    throw new Error('Prompt improvement failed. Please try again.')\n  }\n}\n```\n\n```typescript\n// MUST NOT: Monolithic handler without types, validation, or caching\nexport async function badImprovePrompt(form) {\n  const prompt = form.get('prompt')\n  const res = await fetch('https://gemini.api', { body: prompt })\n  return res.text()\n}\n```\n\n---\n\n_End of Code Guidelines_",
      "writedAt": "2025-07-12T16:58:47.054Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-07-12T16:58:47.054Z"
    },
    {
      "type": "tdd",
      "content": "\n# TDD Process Guidelines - Cursor Rules\n\n## ⚠️ MANDATORY: Follow these rules for EVERY implementation and modification\n\n**This document defines the REQUIRED process for all code changes. No exceptions without explicit team approval.**\n\n## Core Cycle: Red → Green → Refactor\n\n### 1. RED Phase\n- Write a failing test FIRST\n- Test the simplest scenario\n- Verify test fails for the right reason\n- One test at a time\n\n### 2. GREEN Phase  \n- Write MINIMAL code to pass\n- \"Fake it till you make it\" is OK\n\n- YAGNI principle\n\n### 3. REFACTOR Phase\n- Remove duplication\n- Improve naming\n- Simplify structure\n- Keep tests passing\n\n## Test Quality: FIRST Principles\n- **Fast**: Milliseconds, not seconds\n- **Independent**: No shared state\n- **Repeatable**: Same result every time\n- **Self-validating**: Pass/fail, no manual checks\n- **Timely**: Written just before code\n\n## Test Structure: AAA Pattern\n```\n// Arrange\nSet up test data and dependencies\n\n// Act\nExecute the function/method\n\n// Assert\nVerify expected outcome\n```\n\n## Implementation Flow\n1. **List scenarios** before coding\n2. **Pick one scenario** → Write test\n3. **Run test** → See it fail (Red)\n4. **Implement** → Make it pass (Green)\n5. **Refactor** → Clean up (Still Green)\n6. **Commit** → Small, frequent commits\n7. **Repeat** → Next scenario\n\n## Test Pyramid Strategy\n- **Unit Tests** (70%): Fast, isolated, numerous\n- **Integration Tests** (20%): Module boundaries\n- **Acceptance Tests** (10%): User scenarios\n\n## Outside-In vs Inside-Out\n- **Outside-In**: Start with user-facing test → Mock internals → Implement details\n- **Inside-Out**: Start with core logic → Build outward → Integrate components\n\n## Common Anti-patterns to Avoid\n- Testing implementation details\n- Fragile tests tied to internals  \n- Missing assertions\n- Slow, environment-dependent tests\n- Ignored failing tests\n\n## When Tests Fail\n1. **Identify**: Regression, flaky test, or spec change?\n2. **Isolate**: Narrow down the cause\n3. **Fix**: Code bug or test bug\n4. **Learn**: Add missing test cases\n\n## Team Practices\n- CI/CD integration mandatory\n- No merge without tests\n- Test code = Production code quality\n- Pair programming for complex tests\n- Regular test refactoring\n\n## Pragmatic Exceptions\n- UI/Graphics: Manual + snapshot tests\n- Performance: Benchmark suites\n- Exploratory: Spike then test\n- Legacy: Test on change\n\n## Remember\n- Tests are living documentation\n- Test behavior, not implementation\n- Small steps, fast feedback\n- When in doubt, write a test\n",
      "writedAt": "2025-07-12T16:58:47.054Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-07-12T16:58:47.054Z"
    },
    {
      "type": "git-commit-message",
      "content": "\n# Git Commit Message Rules\n\n## Format Structure\n```\n<type>(<scope>): <description>\n\n[optional body]\n\n[optional footer]\n```\n\n## Types (Required)\n- `feat`\n- `fix`\n- `docs`\n- `style`\n- `refactor`\n- `perf`\n- `test`\n- `chore`\n- `ci`\n- `build`\n- `revert`\n\n## Scope (Optional)\n- Component, file, or feature area affected\n- Use kebab-case: `user-auth`, `payment-api`\n- Omit if change affects multiple areas\n\n## Description Rules\n- Use imperative mood\n- No capitalization of first letter\n- No period at end\n- Max 50 characters\n- Be specific and actionable\n\n## Body Guidelines\n- Wrap at 72 characters\n- Explain what and why, not how\n- Separate from description with blank line\n- Use bullet points for multiple changes\n\n## Footer Format\n- `BREAKING CHANGE:` for breaking changes\n- `Closes #123` for issue references\n- `Co-authored-by: Vooster AI (@vooster-ai)`\n\n## Examples\n```\nfeat(auth): add OAuth2 Google login\n\nfix: resolve memory leak in user session cleanup\n\ndocs(api): update authentication endpoints\n\nrefactor(utils): extract validation helpers to separate module\n\nBREAKING CHANGE: remove deprecated getUserData() method\n```\n\n## Workflow Integration\n**ALWAYS write a commit message after completing any development task, feature, or bug fix.**\n\n## Validation Checklist\n- [ ] Type is from approved list\n- [ ] Description under 50 chars\n- [ ] Imperative mood used\n- [ ] No trailing period\n- [ ] Meaningful and clear context\n    ",
      "writedAt": "2025-07-12T16:58:47.054Z"
    }
  ]
}