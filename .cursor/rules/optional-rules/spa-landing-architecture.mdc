---
description: 
globs: 
alwaysApply: true
---
# SPA Landing Architecture & Development Rules

## ğŸ¯ Project Context & Mission
**Project**: Smart Prompt Assistant Landing Page
**Mission**: Create an interactive, conversion-focused landing page that demonstrates AI-powered prompt optimization
**Target**: Solve "blank page syndrome" through engaging user experience

## ğŸ—ï¸ Architecture Principles

### **MUST FOLLOW - Core Architecture Rules**

#### 1. **Next.js App Router Pattern**
- âœ… ALWAYS use App Router (`src/app/`) for routing
- âœ… ALWAYS place page components in `page.tsx` files
- âœ… ALWAYS use `layout.tsx` for shared layouts
- âŒ NEVER use Pages Router (`pages/` directory)
- âŒ NEVER mix routing patterns

#### 2. **Component Organization Hierarchy**
```
src/components/
â”œâ”€â”€ sections/     # Page-specific sections (hero, features, etc.)
â”œâ”€â”€ shared/       # Reusable business components
â”œâ”€â”€ ui/           # Pure UI components (shadcn/ui based)
â”œâ”€â”€ layout/       # Layout-specific components
â”œâ”€â”€ data/         # Static data and configurations
â””â”€â”€ demo/         # Interactive demo components
```

#### 3. **File Naming Conventions**
- âœ… ALWAYS use kebab-case for files: `hero-section.tsx`
- âœ… ALWAYS use PascalCase for components: `HeroSection`
- âœ… ALWAYS use camelCase for functions and variables
- âœ… ALWAYS export components as named exports AND default exports
- âŒ NEVER use snake_case for React components
- âŒ NEVER use default-only exports for components

## ğŸ¨ Design System Rules

### **MUST FOLLOW - UI/UX Standards**

#### 1. **Tailwind CSS Usage**
- âœ… ALWAYS use Tailwind utility classes
- âœ… ALWAYS use design tokens from [tailwind.config.ts](mdc:tailwind.config.ts)
- âœ… ALWAYS use responsive prefixes: `sm:`, `md:`, `lg:`, `xl:`
- âœ… ALWAYS use semantic color names: `primary`, `secondary`, `accent`
- âŒ NEVER write custom CSS unless absolutely necessary
- âŒ NEVER use arbitrary color values outside the design system

#### 2. **Component Composition Pattern**
- âœ… ALWAYS compose using shadcn/ui components from [src/components/ui/](mdc:src/components/ui)
- âœ… ALWAYS extend base components rather than creating from scratch
- âœ… ALWAYS use Radix UI primitives for complex interactions
- âŒ NEVER create custom form controls without Radix UI base

#### 3. **Animation & Interaction Standards**
- âœ… ALWAYS use Framer Motion for complex animations
- âœ… ALWAYS use Tailwind transitions for simple hover effects
- âœ… ALWAYS implement loading states for async operations
- âŒ NEVER use CSS animations for complex state transitions
- âŒ NEVER skip loading/pending states

## ğŸ”§ TypeScript & Code Quality

### **MUST FOLLOW - Type Safety Rules**

#### 1. **Type Definitions**
- âœ… ALWAYS define types in [src/types/](mdc:src/types) directory
- âœ… ALWAYS use interfaces for object shapes
- âœ… ALWAYS use union types for component variants
- âœ… ALWAYS export types alongside components
- âŒ NEVER use `any` type unless interfacing with untyped libraries
- âŒ NEVER skip type annotations for component props

#### 2. **Import/Export Patterns**
- âœ… ALWAYS use absolute imports from `src/`
- âœ… ALWAYS use barrel exports in `index.ts` files
- âœ… ALWAYS group imports: React â†’ Third-party â†’ Internal
- âŒ NEVER use relative imports beyond one level (`../`)
- âŒ NEVER import entire libraries when tree-shaking is possible

## ğŸ“Š Data Management Rules

### **MUST FOLLOW - State & Data Patterns**

#### 1. **State Management Strategy**
- âœ… ALWAYS use React state for component-local state
- âœ… ALWAYS use SWR for server state (see [src/hooks/](mdc:src/hooks))
- âœ… ALWAYS use React Hook Form for form state
- âœ… ALWAYS validate with Zod schemas
- âŒ NEVER use Redux or Zustand for this project
- âŒ NEVER manage server state manually

#### 2. **Data Flow Patterns**
- âœ… ALWAYS define data types in [src/types/smart-prompt.ts](mdc:src/types/smart-prompt.ts)
- âœ… ALWAYS use static data from [src/components/data/](mdc:src/components/data)
- âœ… ALWAYS implement error boundaries for API calls
- âŒ NEVER fetch data directly in components without hooks
- âŒ NEVER ignore error states

## ğŸš€ Performance & Optimization

### **MUST FOLLOW - Performance Rules**

#### 1. **Code Splitting & Loading**
- âœ… ALWAYS use dynamic imports for heavy components
- âœ… ALWAYS implement Suspense boundaries
- âœ… ALWAYS optimize images with Next.js Image component
- âŒ NEVER import heavy libraries synchronously
- âŒ NEVER skip image optimization

#### 2. **Bundle Optimization**
- âœ… ALWAYS use tree-shakable imports: `import { Button } from 'lucide-react'`
- âœ… ALWAYS check bundle size impact of new dependencies
- âŒ NEVER import entire icon libraries
- âŒ NEVER add dependencies without justification

## ğŸ”’ Security & Best Practices

### **MUST FOLLOW - Security Rules**

#### 1. **API & Data Security**
- âœ… ALWAYS validate API inputs with Zod
- âœ… ALWAYS use environment variables for secrets
- âœ… ALWAYS sanitize user inputs
- âŒ NEVER expose API keys in client code
- âŒ NEVER trust user input without validation

#### 2. **Accessibility Standards**
- âœ… ALWAYS use semantic HTML elements
- âœ… ALWAYS provide ARIA labels for interactive elements
- âœ… ALWAYS ensure keyboard navigation works
- âœ… ALWAYS test with screen readers
- âŒ NEVER rely solely on color for information
- âŒ NEVER skip focus management

## ğŸ“± Responsive Design Rules

### **MUST FOLLOW - Mobile-First Approach**

#### 1. **Breakpoint Strategy**
- âœ… ALWAYS design mobile-first (320px+)
- âœ… ALWAYS test on tablet (768px+) and desktop (1024px+)
- âœ… ALWAYS use Tailwind responsive prefixes
- âŒ NEVER assume desktop-first behavior
- âŒ NEVER hardcode pixel values

#### 2. **Touch & Interaction**
- âœ… ALWAYS ensure touch targets are 44px minimum
- âœ… ALWAYS implement swipe gestures where appropriate
- âœ… ALWAYS optimize for thumb navigation
- âŒ NEVER rely on hover states for critical functionality
- âŒ NEVER ignore touch device limitations

## ğŸ§ª Testing & Quality Assurance

### **MUST FOLLOW - Testing Standards**

#### 1. **Component Testing**
- âœ… ALWAYS test component rendering and interactions
- âœ… ALWAYS test responsive behavior
- âœ… ALWAYS test accessibility features
- âŒ NEVER skip testing for user-facing components
- âŒ NEVER commit without running tests

#### 2. **Code Quality Gates**
- âœ… ALWAYS run ESLint before commits
- âœ… ALWAYS fix TypeScript errors immediately
- âœ… ALWAYS maintain 90%+ test coverage for utilities
- âŒ NEVER ignore linting warnings
- âŒ NEVER commit broken builds

## ğŸ­ Component Development Patterns

### **MUST FOLLOW - Component Design Rules**

#### 1. **Component Structure Template**
```typescript
// 1. Imports (React, Third-party, Internal)
// 2. Types & Interfaces
// 3. Component Definition
// 4. Default Export
// 5. Named Export (for testing)
```

#### 2. **Props Design Patterns**
- âœ… ALWAYS use discriminated unions for variant props
- âœ… ALWAYS provide sensible defaults
- âœ… ALWAYS document complex props with JSDoc
- âŒ NEVER use boolean props for more than 2 states
- âŒ NEVER create props that conflict with each other

## ğŸ”„ Development Workflow

### **MUST FOLLOW - Git & Deployment Rules**

#### 1. **Commit Standards**
- âœ… ALWAYS use conventional commits
- âœ… ALWAYS test locally before pushing
- âœ… ALWAYS update documentation for API changes
- âŒ NEVER commit directly to main branch
- âŒ NEVER push without testing

#### 2. **Code Review Requirements**
- âœ… ALWAYS review for accessibility compliance
- âœ… ALWAYS check mobile responsiveness
- âœ… ALWAYS verify TypeScript strict mode compliance
- âŒ NEVER approve without testing the changes
- âŒ NEVER skip performance impact assessment

---

## ğŸ¯ Success Metrics & Goals

### **Primary Objectives**
1. **Conversion Rate**: Maximize email registrations
2. **User Engagement**: Increase demo interaction time
3. **Performance**: Maintain 90+ Lighthouse scores
4. **Accessibility**: Achieve WCAG 2.1 AA compliance

### **Quality Gates**
- Zero TypeScript errors
- Zero accessibility violations
- 100% responsive design coverage
- Sub-3s initial page load time

---

*Remember: These rules exist to ensure consistent, high-quality, and maintainable code. When in doubt, prioritize user experience and code clarity over clever solutions.*

